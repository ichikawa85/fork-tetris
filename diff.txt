> void game_server()
> {
>   struct sockaddr_in client;
>   socklen_t len = sizeof(client);
>   int client_sock = accept(s1, (struct sockaddr *)&client, &len);
>   if(client_sock != 0){
>     int j = 0;
>     while(j < FD_SETSIZE && accept_list[j] != 0) j++;
>     if(j != FD_SETSIZE){
>       FD_SET(client_sock, &readfds);
>       accept_list[j] = client_sock;
>       printf("accept\n");
>     }else{
>       printf("no empty\n");
>     }
>   }else{
>     printf("accept error\n");
>   }
> }

<       if(FD_ISSET(client_sock, &fds)){
<       	read(client_sock,read_buf,BUFSIZ);
---
>       if(FD_ISSET(s1, &fds)){
> 	game_server();
>       }
>       if(FD_ISSET(accept_list[0], &fds)){
>       	read(accept_list[0],read_buf,BUFSIZ);

>   case 'f': /* fork game */
>     sprintf(str1,"FORK");
>     strcpy(buf, str1);
>     if(accept_list[0]>0)write(accept_list[0], buf, sizeof(buf));
>     if( (pid=fork()) <0 ) {
>       perror("fork");
>       exit(0);
>     } else if(pid==0) {
>       //tetris(sock); //fork at new port
>     }
>     break;
